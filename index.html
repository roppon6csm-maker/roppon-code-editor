<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="screen-orientation" content="portrait">
<!--
ゲーム要件:
App Name: Roppon Code Editor
Type: Web Application
Platform: iPhone (Portrait Only)
Orientation: Portrait Fixed
Screen Structure: 1 Screen, No Transition
Layout: Header 10%, List 70%, Bottom Margin 20% (Empty, No UI)
Features:
- BPM: Immediate/Pending update logic
- Key: 0-11 Integer, Transpose immediately, No flats
- Loop: Playlist filter (Top to Bottom, Skip OFF)
- Audio: Drum + Piano, No silent frames
- Storage: LocalStorage Auto Save/Load
-->
<title>Roppon Code Editor</title>
<style>
/* CSS Reset & Basics */
* { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
body { margin: 0; padding: 0; background-color: #000000; color: #ffffff; overflow: hidden; width: 100vw; height: 100vh; touch-action: none; }
input, select, button { outline: none; border: none; background: none; color: inherit; font-family: inherit; }

/* Layout Grid */
#app { display: flex; flex-direction: column; width: 100%; height: 100%; overflow: hidden; }

/* Header (10%) */
header { flex: 0 0 10%; width: 100%; padding-top: env(safe-area-inset-top); background: #000; z-index: 10; display: flex; flex-direction: column; align-items: center; padding-bottom: 1vh; }
.app-title { width: 100%; text-align: center; font-size: 4.5vw; font-weight: bold; color: #fff; margin-bottom: 2vh; }
.header-content { width: 96%; margin: 0 auto; height: 70%; display: flex; justify-content: space-between; gap: 1.5vw; }

.setting-group { flex: 1; display: flex; flex-direction: column; justify-content: flex-end; background: #1a1a1a; border-radius: 8px; position: relative; height: 100%; }
.setting-label { position: absolute; top: -2vh; left: 0; width: 100%; text-align: center; font-size: 2.4vw; color: #888; font-weight: bold; }

/* Global Select Styles */
.global-select { width: 100%; height: 100%; text-align: center; font-size: 4.8vw; font-weight: bold; color: #fff; background: transparent; appearance: none; border-radius: 8px; padding: 0; text-align-last: center; }
.global-select:focus { background: #222; }

/* Specific colors */
#bpm-select { color: #4CCFFF; }
#key-select { color: #FFD60A; }
#beat-select { color: #FF9F0A; }
#drum-select { color: #32D74B; }

/* Main List (70%) */
#list-wrapper { flex: 0 0 70%; display: flex; flex-direction: column; position: relative; overflow: hidden; }

/* Headers for columns */
.col-headers { display: flex; width: 100%; padding: 0 4vw; height: 4vh; align-items: center; color: #666; font-size: 3.2vw; font-weight: bold; background: #000; flex-shrink: 0; }
.col-h-loop { width: 8%; }
.col-h-part { width: 18%; margin-left: 1%; }
.col-h-chord { width: 38%; margin-left: 2%; }
.col-h-tmpl { width: 36%; margin-left: 2%; }

main { flex: 1; overflow-y: auto; position: relative; padding: 1vh 3% 20vh 3%; -webkit-overflow-scrolling: touch; width: 100%; }
main::-webkit-scrollbar { display: none; }

.line-row { height: 8.2vh; display: flex; align-items: center; justify-content: space-between; margin-bottom: 1vh; position: relative; background: #111; border-radius: 10px; padding: 0 1.5vw; transition: all 0.2s; flex-shrink: 0; }
.line-row.playing { border: 1.5px solid #4CCFFF; box-shadow: 0 0 16px rgba(76, 207, 255, 0.5); }

/* Loop Btn - glow強化 */
.loop-btn { width: 6.5vw; height: 6.5vw; border-radius: 50%; border: 2.5px solid #555; cursor: pointer; transition: all 0.2s; flex-shrink: 0; margin-left: 0.5vw; }
.loop-btn.active { background-color: #4CCFFF; border-color: #4CCFFF; box-shadow: 0 0 20px #4CCFFF, 0 0 40px #4CCFFF88; }

/* Part Select - 背景色をPartごとに変更 */
.part-wrapper { position: relative; width: 18%; height: 80%; }
.part-wrapper::after { content: '▼'; position: absolute; right: 0.8vw; top: 50%; transform: translateY(-50%); font-size: 2vw; color: #fff; pointer-events: none; }
.part-wrapper select { width: 100%; height: 100%; border-radius: 6px; padding: 0 2vw 0 1vw; font-size: 3vw; font-weight: bold; color: #fff; appearance: none; cursor: pointer; border: none; }

/* Partごとの背景色（視認性重視・ユニーク） */
.part-Intro     select { background: #4682B4; } /* イントロ: 青 */
.part-A         select { background: #FF8C00; } /* A: オレンジ */
.part-B         select { background: #32CD32; } /* B: 緑 */
.part-Pre-Chorus select { background: #9932CC; } /* プレ: 紫 */
.part-Chorus    select { background: #FF1493; } /* サビ: ピンク */
.part-Interlude select { background: #00CED1; } /* 間奏: 水色 */
.part-C         select { background: #FFD700; } /* C: 金 */
.part-Outro     select { background: #A0522D; } /* アウトロ: 茶 */

/* Chords Input - 青文字 + 鉛筆アイコン */
.chord-wrapper { position: relative; width: 38%; height: 80%; }
.chords-input { width: 100%; height: 100%; background: #222; border-radius: 6px; font-size: 3.4vw; color: #4CCFFF; padding: 0 4vw 0 1.5vw; border: 1px solid #333; }
.chords-input::placeholder { color: #555; font-size: 2.8vw; }
.edit-icon { position: absolute; right: 1.2vw; top: 50%; transform: translateY(-50%); font-size: 3.8vw; color: #4CCFFF; opacity: 0.9; pointer-events: none; }

/* Template Select */
.template-wrapper { position: relative; width: 36%; height: 80%; }
.template-wrapper::after { content: '▼'; position: absolute; right: 0.8vw; top: 50%; transform: translateY(-50%); font-size: 2vw; color: #4CCFFF; pointer-events: none; }
.template-wrapper select { width: 100%; height: 100%; background: #222; color: #ccc; border-radius: 6px; padding: 0 2vw 0 1vw; font-size: 3vw; }

/* Add Button */
.add-btn { width: 100%; height: 9vh; background: none; color: #666; font-size: 10vw; display: flex; align-items: center; justify-content: center; cursor: pointer; font-weight: bold; margin-top: 1vh; flex-shrink: 0; }
.add-btn:active { color: #aaa; }

/* Controls Overlay */
.controls-overlay { position: absolute; bottom: 0; left: 0; width: 100%; height: 28%; display: flex; flex-direction: column; align-items: center; justify-content: flex-end; pointer-events: none; background: linear-gradient(to top, #000 40%, transparent); z-index: 50; padding-bottom: 2vh; }

.page-dots { display: flex; gap: 2vw; margin-bottom: 4vh; }
.dot { width: 1.4vw; height: 1.4vw; border-radius: 50%; background: #444; }
.dot.active { background: #4CCFFF; box-shadow: 0 0 10px #4CCFFF; }

.play-btn { width: 24vw; height: 24vw; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 5vw; font-weight: bold; color: #fff; cursor: pointer; box-shadow: 0 6px 20px rgba(0,0,0,0.6), 0 0 30px rgba(52,199,89,0.5); transition: transform 0.1s; pointer-events: auto; z-index: 51; }
.play-btn.stop { background: #FF3B30; box-shadow: 0 6px 20px rgba(0,0,0,0.6), 0 0 30px rgba(255,59,48,0.5); }
.play-btn.play { background: #34C759; }
.play-btn:active { transform: scale(0.94); }

/* Bottom Spacer (20%) */
#bottom-spacer { flex: 0 0 20%; width: 100%; background: #000; padding-bottom: env(safe-area-inset-bottom); }

</style>
</head>
<body>

<div id="app">
  <header>
    <div class="app-title">Roppon Code Editor</div>
    <div class="header-content">
      <div class="setting-group">
        <div class="setting-label">BPM</div>
        <select id="bpm-select" class="global-select"></select>
      </div>
      <div class="setting-group">
        <div class="setting-label">KEY</div>
        <select id="key-select" class="global-select"></select>
      </div>
      <div class="setting-group">
        <div class="setting-label">BEAT</div>
        <select id="beat-select" class="global-select">
          <option value="4">4</option>
          <option value="8" selected>8</option>
          <option value="16">16</option>
        </select>
      </div>
      <div class="setting-group">
        <div class="setting-label">DRUM</div>
        <select id="drum-select" class="global-select">
          <option value="1" selected>METRO</option>
          <option value="2">BASIC</option>
          <option value="3">HOUSE</option>
          <option value="4">ROCK8</option>
          <option value="5">DANCE16</option>
        </select>
      </div>
    </div>
  </header>

  <div id="list-wrapper">
    <div class="col-headers">
      <div class="col-h-loop">roop</div>
      <div class="col-h-part">Part</div>
      <div class="col-h-chord">Chords</div>
      <div class="col-h-tmpl">Template</div>
    </div>
    <main id="line-container">
      <!-- Lines injected here -->
      <div class="add-btn" id="add-btn">+</div>
    </main>
    <div class="controls-overlay">
      <div class="page-dots">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot active"></div>
        <div class="dot"></div>
      </div>
      <div class="play-btn play" id="play-btn">PLAY</div>
    </div>
  </div>

  <div id="bottom-spacer"></div>
</div>

<script>
// --- Constants & Data ---
const KEYS = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
const PARTS = ["Intro", "A", "B", "Pre-Chorus", "Chorus", "Interlude", "C", "Outro"];
const PARTS_DISPLAY = ["イントロ", "Aメロ", "Bメロ", "プレコーラス", "サビ", "間奏", "Cメロ", "アウトロ"];

// Templates with Degrees
const TEMPLATES = [
  { name: "王道進行", deg: ["I", "V", "vi", "IV"], usage: "サビ最頻出" },
  { name: "マイナー王道", deg: ["vi", "IV", "I", "V"], usage: "切な系サビ" },
  { name: "逆王道", deg: ["IV", "V", "iii", "vi"], usage: "A・Bメロ" },
  { name: "小室進行", deg: ["vi", "IV", "V", "I"], usage: "90s疾走" },
  { name: "丸サ進行", deg: ["IV", "V", "iii", "vi"], usage: "歌い出し" },
  { name: "カノン進行", deg: ["I", "V", "vi", "iii", "IV", "I", "IV", "V"], usage: "バラード" },
  { name: "4度進行", deg: ["I", "IV", "V", "I"], usage: "明るい" },
  { name: "泣き進行", deg: ["I", "iii", "vi", "V"], usage: "感動" },
  { name: "青春進行", deg: ["I", "V", "IV", "V"], usage: "爽やか" },
  { name: "Bメロ定番", deg: ["ii", "V", "I"], usage: "解決感" },
  { name: "ロック定番", deg: ["I", "bVII", "IV"], usage: "洋楽風" },
  { name: "エモ進行", deg: ["vi", "I", "V", "IV"], usage: "エモい" }
];

// Degree to Semitone Offset from Root
const DEGREE_MAP = {
  "I": 0, "II": 2, "ii": 2, "III": 4, "iii": 4, "IV": 5, "V": 7, "VI": 9, "vi": 9, "VII": 11, "bVII": 10
};

// --- State ---
let state = {
  bpm: 120,
  pendingBPM: null,
  keyIndex: 0,
  beat: 8,
  drum: 1, // HAT → DRUM に変更
  isPlaying: false,
  lines: [],
  currentLineIndex: -1,
  nextNoteTime: 0,
  currentBeat: 0
};

// --- Audio Context --- (省略せず維持)
let audioCtx;
let keepAliveOsc = null;
let lookahead = 25.0;
let scheduleAheadTime = 0.1;
let timerID;

// --- Transposition & Chords functions --- (前バージョンと同じ)
function getNoteFromKey(degree, keyIndex) {
  let offset = DEGREE_MAP[degree] || 0;
  let noteIndex = (keyIndex + offset) % 12;
  let noteName = KEYS[noteIndex];
  let quality = "";
  if (degree === "ii" || degree === "iii" || degree === "vi") quality = "m";
  if (degree.match(/^[a-z]/) && degree !== "bVII") quality = "m";
  return noteName + quality;
}

function generateChordsFromTemplate(templateIndex, keyIndex) {
  if (templateIndex === "") return "";
  const tmpl = TEMPLATES[templateIndex];
  if (!tmpl) return "";
  return tmpl.deg.map(d => getNoteFromKey(d, keyIndex)).join("-");
}

function transposeChordString(chordStr, semitones) {
  if (!chordStr) return "";
  return chordStr.split("-").map(c => {
    c = c.trim();
    if (!c) return "";
    let match = c.match(/^([A-G])(#|b)?(.*)$/);
    if (!match) return c;
    let root = match[1];
    let acc = match[2] || "";
    let suffix = match[3] || "";
    let note = root + acc;
    if (note === "Db") note = "C#";
    if (note === "Eb") note = "D#";
    if (note === "Gb") note = "F#";
    if (note === "Ab") note = "G#";
    if (note === "Bb") note = "A#";
    if (note === "Cb") note = "B";
    let idx = KEYS.indexOf(note);
    if (idx === -1) return c;
    let newIdx = (idx + semitones + 12) % 12;
    return KEYS[newIdx] + suffix;
  }).join("-");
}

// --- UI Rendering ---
const container = document.getElementById('line-container');
const bpmSelect = document.getElementById('bpm-select');
const keySelect = document.getElementById('key-select');
const beatSelect = document.getElementById('beat-select');
const drumSelect = document.getElementById('drum-select');
const playBtn = document.getElementById('play-btn');

function populateSelects() {
  for (let i = 60; i <= 200; i++) {
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = i;
    bpmSelect.appendChild(opt);
  }
  KEYS.forEach((key, index) => {
    const opt = document.createElement('option');
    opt.value = index;
    opt.textContent = key;
    keySelect.appendChild(opt);
  });
}

function renderLine(line, index) {
  const div = document.createElement('div');
  div.className = 'line-row';
  div.dataset.index = index;

  const loopBtn = document.createElement('div');
  loopBtn.className = `loop-btn ${line.loop ? 'active' : ''}`;
  loopBtn.onclick = () => toggleLoop(index);

  const partWrap = document.createElement('div');
  partWrap.className = 'part-wrapper';
  const partSel = document.createElement('select');
  partSel.innerHTML = PARTS.map((p, i) => `<option value="${p}" ${p===line.part?'selected':''}>${PARTS_DISPLAY[i]}</option>`).join('');
  partSel.onchange = (e) => updateLine(index, 'part', e.target.value);
  // Partごとのクラスを追加（背景色変更）
  partSel.classList.add(`part-${line.part}`);
  partWrap.appendChild(partSel);

  const chordWrap = document.createElement('div');
  chordWrap.className = 'chord-wrapper';
  const chordIn = document.createElement('input');
  chordIn.className = 'chords-input';
  chordIn.value = line.chords;
  chordIn.placeholder = "例: C-G-Am-F";
  chordIn.onchange = (e) => updateLine(index, 'chords', e.target.value);
  chordWrap.appendChild(chordIn);

  const pencil = document.createElement('span');
  pencil.className = 'edit-icon';
  pencil.textContent = '✏️';
  chordWrap.appendChild(pencil);

  const tempWrap = document.createElement('div');
  tempWrap.className = 'template-wrapper';
  const tempSel = document.createElement('select');
  const options = TEMPLATES.map((t, i) => {
    const cEx = t.deg.map(d => getNoteFromKey(d, state.keyIndex)).join("-");
    const label = `${t.name} / ${t.deg.join("-")} / ${cEx} / ${t.usage}`;
    return `<option value="${i}" ${i.toString()===line.template?'selected':''}>${label}</option>`;
  }).join('');
  tempSel.innerHTML = '<option value="">Template</option>' + options;
  tempSel.onchange = (e) => applyTemplate(index, e.target.value);
  tempWrap.appendChild(tempSel);

  div.appendChild(loopBtn);
  div.appendChild(partWrap);
  div.appendChild(chordWrap);
  div.appendChild(tempWrap);

  return div;
}

function refreshUI() {
  const btn = document.getElementById('add-btn');
  while (container.firstChild && container.firstChild !== btn) {
    container.removeChild(container.firstChild);
  }
  state.lines.forEach((line, i) => {
    container.insertBefore(renderLine(line, i), btn);
  });

  bpmSelect.value = state.bpm;
  keySelect.value = state.keyIndex;
  beatSelect.value = state.beat;
  drumSelect.value = state.drum;
}

function updateLine(index, field, value) {
  state.lines[index][field] = value;
  saveData();
  refreshUI();
}

function toggleLoop(index) {
  state.lines[index].loop = !state.lines[index].loop;
  refreshUI();
  saveData();
}

function applyTemplate(index, tempIndex) {
  if (tempIndex === "") return;
  state.lines[index].template = tempIndex;
  const chords = generateChordsFromTemplate(tempIndex, state.keyIndex);
  state.lines[index].chords = chords;
  refreshUI();
  saveData();
}

function addLine() {
  state.lines.push({
    loop: false,
    part: "A",
    chords: "",
    template: ""
  });
  refreshUI();
  container.scrollTop = container.scrollHeight;
  saveData();
}

// --- Global Handlers ---
keySelect.onchange = (e) => {
  const newKeyIndex = parseInt(e.target.value);
  const delta = newKeyIndex - state.keyIndex;
  state.keyIndex = newKeyIndex;
  state.lines.forEach(line => {
    line.chords = transposeChordString(line.chords, delta);
  });
  refreshUI();
  saveData();
};

bpmSelect.onchange = (e) => {
  let val = parseInt(e.target.value);
  if (state.isPlaying) {
    state.pendingBPM = val;
  } else {
    state.bpm = val;
    saveData();
  }
};

beatSelect.onchange = (e) => {
  state.beat = parseInt(e.target.value);
  saveData();
};

drumSelect.onchange = (e) => {
  state.drum = parseInt(e.target.value);
  saveData();
};

document.getElementById('add-btn').onclick = addLine;

// --- Storage ---
function saveData() {
  localStorage.setItem('ropponState', JSON.stringify(state));
}

function loadData() {
  const saved = localStorage.getItem('ropponState');
  if (saved) {
    state = JSON.parse(saved);
  }
  refreshUI();
}

// --- Audio Engine --- (前バージョンと同じ、Drumは後回しのため未変更)
function initAudio() {
  if (!audioCtx) {
    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContextClass({ latencyHint: "interactive" });
  }
}

async function unlockAudio() {
  if (!audioCtx) initAudio();
  if (audioCtx.state !== "running") {
    await audioCtx.resume();
  }
  if (!keepAliveOsc) {
    keepAliveOsc = audioCtx.createOscillator();
    keepAliveOsc.type = 'sine';
    keepAliveOsc.frequency.value = 1;
    const gain = audioCtx.createGain();
    gain.gain.value = 0.0001;
    keepAliveOsc.connect(gain);
    gain.connect(audioCtx.destination);
    keepAliveOsc.start(0);
  }
}

document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible' && audioCtx) {
    if (audioCtx.state !== 'running') audioCtx.resume();
  }
});

function playTone(freq, time, duration, type = 'triangle') {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start(time);
  gain.gain.setValueAtTime(0.3, time);
  gain.gain.exponentialRampToValueAtTime(0.01, time + duration);
  osc.stop(time + duration);
}

function playDrum(time, type) {
  // 省略（Drum本格実装は後回し）
  // METROだけ仮で高音ビープ音
  if (type === 'metro') {
    playTone(880, time, 0.03, 'sine'); // 高音短いビープ
  }
}

// --- Scheduler & Play Control --- (前バージョンと同じ)
function getFirstActiveLineIndex() {
  return state.lines.findIndex(l => l.loop);
}

function getNextActiveLineIndex(current) {
  for (let i = current + 1; i < state.lines.length; i++) {
    if (state.lines[i].loop) return i;
  }
  for (let i = 0; i < state.lines.length; i++) {
    if (state.lines[i].loop) return i;
  }
  return -1;
}

function nextNote() {
  const beatTime = 60 / state.bpm / (state.beat / 4);
  state.nextNoteTime += beatTime;
  state.currentBeat++;

  if (state.currentLineIndex === -1) return;

  const currentLine = state.lines[state.currentLineIndex];
  const chords = currentLine.chords.split("-").filter(c => c.trim());
  if (chords.length === 0) {
    state.currentBeat = 0;
    const nextIndex = getNextActiveLineIndex(state.currentLineIndex);
    if (nextIndex !== -1) {
      updatePlayingClass(nextIndex);
      state.currentLineIndex = nextIndex;
    }
    return;
  }

  const beatsPerChord = state.beat;
  const beatsPerLine = chords.length * beatsPerChord;

  if (state.currentBeat >= beatsPerLine) {
    state.currentBeat = 0;
    const nextIndex = getNextActiveLineIndex(state.currentLineIndex);
    if (nextIndex === -1) {
      playBtn.click();
    } else {
      updatePlayingClass(nextIndex);
      state.currentLineIndex = nextIndex;
    }
  }
}

function updatePlayingClass(newIndex) {
  document.querySelectorAll('.line-row').forEach(el => el.classList.remove('playing'));
  const newEl = document.querySelector(`.line-row[data-index="${newIndex}"]`);
  if (newEl) newEl.classList.add('playing');
}

function scheduleNote(beatNumber, time) {
  if (state.currentLineIndex === -1) return;

  const currentLine = state.lines[state.currentLineIndex];
  const chords = currentLine.chords.split("-").filter(c => c.trim());
  if (chords.length === 0) return;

  const beatsPerChord = state.beat;
  const chordIndex = Math.floor(beatNumber / beatsPerChord);
  const beatInChord = beatNumber % beatsPerChord;

  if (beatInChord === 0 && chordIndex < chords.length) {
    const chord = chords[chordIndex].trim();
    if (!chord) return;
    let rootNote = chord.replace(/m$/, '');
    const isMinor = chord.endsWith('m');
    const rootIndex = KEYS.indexOf(rootNote);
    if (rootIndex === -1) return;
    const third = isMinor ? 3 : 4;
    const fifth = 7;
    const notes = [rootIndex, (rootIndex + third) % 12, (rootIndex + fifth) % 12];
    notes.forEach(offset => {
      const midi = 60 + offset;
      const freq = 440 * Math.pow(2, (midi - 69) / 12);
      playTone(freq, time, 0.5, 'triangle');
    });
  }

  // Drum (仮：METROのみビープ)
  if (state.drum === 1 && beatInChord % (state.beat / 4) === 0) {
    playDrum(time, 'metro');
  }
}

function scheduler() {
  while (state.nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
    scheduleNote(state.currentBeat, state.nextNoteTime);
    nextNote();
  }
  timerID = window.setTimeout(scheduler, lookahead);
}

playBtn.onclick = async () => {
  if (!audioCtx) initAudio();
  await audioCtx.resume();

  if (state.isPlaying) {
    state.isPlaying = false;
    window.clearTimeout(timerID);
    playBtn.textContent = "PLAY";
    playBtn.className = "play-btn play";
    document.querySelectorAll('.line-row').forEach(el => el.classList.remove('playing'));
    state.currentBeat = 0;
    state.currentLineIndex = -1;
    if (state.pendingBPM !== null) {
      state.bpm = state.pendingBPM;
      state.pendingBPM = null;
      bpmSelect.value = state.bpm;
      saveData();
    }
  } else {
    if (state.lines.length === 0 || getFirstActiveLineIndex() === -1) return;
    await unlockAudio();
    state.isPlaying = true;
    state.currentBeat = 0;
    state.currentLineIndex = getFirstActiveLineIndex();
    state.nextNoteTime = audioCtx.currentTime + 0.1;
    playBtn.textContent = "STOP";
    playBtn.className = "play-btn stop";
    updatePlayingClass(state.currentLineIndex);
    scheduler();
  }
};

// --- Initialize ---
populateSelects();
loadData();
</script>
</body>
</html>
