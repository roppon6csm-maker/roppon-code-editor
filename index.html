<!-- Ver.1.7 - 2025/02/07 大介さん向け修正版 -->
<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="screen-orientation" content="portrait">
<title>Roppon Code Editor</title>
<style>
/* Ver.1.7 CSS - タイトル灰色 + +ボタンPLAYの上配置 + レスポンシブ強化 */
* { box-sizing: border-box; margin:0; padding:0; -webkit-tap-highlight-color: transparent; user-select: none; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
body { background:#000; color:#fff; overflow:hidden; height:100vh; touch-action:none; }

#app { display:flex; flex-direction:column; height:100%; }

header { flex:0 0 12%; padding-top:env(safe-area-inset-top, 20px); background:#000; display:flex; flex-direction:column; align-items:center; }
.app-title { 
  width:100%; 
  text-align:center; 
  font-size:clamp(4.5vw, 6vw, 32px); 
  font-weight:900; 
  letter-spacing:1px; 
  color:#888; /* 灰色に変更 (KEYラベルと同じ) */
  padding:clamp(2vh, 3vh, 20px) 0 1.5vh 0; 
}

.header-content { width:96%; margin:0 auto; display:flex; justify-content:space-between; gap:clamp(1vw, 1.5vw, 12px); padding-bottom:1.8vh; flex:1; }
.setting-group { flex:1; background:#1a1a1a; border-radius:10px; position:relative; height:clamp(7vh, 8vh, 60px); display:flex; align-items:center; justify-content:center; min-width:0; text-align:center; }
.setting-label { 
  position:absolute; 
  top:-1.4vh; 
  left:50%; 
  transform:translateX(-50%); 
  font-size:clamp(2vw, 2.3vw, 14px); 
  color:#888; 
  font-weight:600; 
  background:#000; 
  padding:0 8px; 
  white-space:nowrap; 
  z-index:1;
}
.global-select { 
  width:90%; 
  height:80%; 
  font-size:clamp(4.5vw, 5.2vw, 28px); 
  font-weight:700; 
  text-align:center; 
  background:transparent; 
  color:inherit; 
  appearance:none; 
  border:none; 
}

/* Colors */
#bpm-select { color:#4CCFFF; }
#key-select { color:#FFD60A; }
#beat-select { color:#FF9F0A; }
#drum-select { color:#32D74B; }

/* List Header */
.col-headers { display:flex; color:#777; font-size:clamp(3vw, 3.4vw, 16px); font-weight:600; padding:1.2vh 4vw 0.6vh; background:#000; }
.col-headers > div { text-align:center; flex:1; }

/* Main List */
main { flex:1; overflow-y:auto; padding:0 3vw 30vh; -webkit-overflow-scrolling:touch; position:relative; }
main::-webkit-scrollbar { display:none; }

.line-row { display:flex; align-items:center; background:#111; border-radius:10px; margin-bottom:1vh; padding:1vh 2vw; min-height:7.2vh; transition: all 0.18s; }
.line-row.playing { border:2px solid #4CCFFF; box-shadow:0 0 24px #4CCFFFaa, 0 0 48px #4CCFFF44; background:#1a1a1a; }

/* Loop Button */
.loop-btn { width:7vw; height:7vw; border-radius:50%; border:3px solid #555; flex-shrink:0; margin-right:2.2vw; transition: all 0.18s; }
.loop-btn.active { background:#4CCFFF; border-color:#4CCFFF; box-shadow:0 0 28px #4CCFFF, 0 0 56px #4CCFFF88, inset 0 0 12px #ffffff66; }

/* Part Select */
.part-wrapper { position:relative; width:19%; height:100%; }
.part-wrapper select { width:100%; height:100%; font-size:3.3vw; font-weight:700; color:#fff; border:none; border-radius:8px; padding:0 2.5vw 0 1.2vw; appearance:none; text-align:center; cursor:pointer; }
.part-wrapper::after { content:'▼'; position:absolute; right:1.2vw; top:50%; transform:translateY(-50%); color:#fff; font-size:2.2vw; pointer-events:none; }

/* Part背景色 */
.part-Intro     select { background:#4682B4; }
.part-A         select { background:#FF8C00; }
.part-B         select { background:#32CD32; }
.part-Pre-Chorus select { background:#9932CC; }
.part-Chorus    select { background:#FF1493; }
.part-Interlude select { background:#00CED1; }
.part-C         select { background:#FFD700; }
.part-Outro     select { background:#A0522D; }

/* Chords */
.chord-wrapper { position:relative; width:37%; height:100%; }
.chords-input { width:100%; height:100%; background:#222; color:#4CCFFF; font-size:3.5vw; border:none; border-radius:8px; padding:0 5vw 0 1.5vw; }
.chords-input::placeholder { color:#555; font-size:2.8vw; }
.edit-icon { position:absolute; right:1.8vw; top:50%; transform:translateY(-50%); font-size:4.2vw; color:#4CCFFF; opacity:0.85; pointer-events:none; }

/* Template */
.template-wrapper { width:35%; height:100%; }
.template-wrapper select { width:100%; height:100%; background:#222; color:#ccc; font-size:3.1vw; border:none; border-radius:8px; padding:0 2.5vw 0 1.2vw; appearance:none; }

/* Add Button - PLAYの上に配置 (controls-overlay内に移動) */
.add-btn { 
  width:clamp(8vw, 10vw, 50px); 
  height:clamp(8vw, 10vw, 50px); 
  background:none; 
  color:#666; 
  font-size:clamp(8vw, 10vw, 50px); 
  display:flex; 
  align-items:center; 
  justify-content:center; 
  cursor:pointer; 
  font-weight:bold; 
  margin-bottom:2vh; 
  touch-action:manipulation; 
}
.add-btn:active { color:#aaa; }

/* Controls - +ボタンをPLAYの上に追加 */
.controls-overlay { position:absolute; bottom:0; left:0; width:100%; height:30vh; display:flex; flex-direction:column; align-items:center; justify-content:flex-end; background:linear-gradient(to top,#000 45%,transparent); z-index:50; padding-bottom:env(safe-area-inset-bottom, 20px); pointer-events:none; }
.controls-overlay * { pointer-events:auto; } /* タップ可能にする */
.page-dots { display:flex; gap:2.8vw; margin-bottom:3vh; }
.dot { width:1.6vw; height:1.6vw; border-radius:50%; background:#444; }
.dot.active { background:#4CCFFF; box-shadow:0 0 12px #4CCFFF; }

.play-btn { 
  width:26vw; 
  height:26vw; 
  border-radius:50%; 
  background:#34C759; 
  color:#fff; 
  font-size:5.8vw; 
  font-weight:900; 
  display:flex; 
  align-items:center; 
  justify-content:center; 
  box-shadow:0 10px 30px #000A, 0 0 40px #34C75988; 
  margin-bottom:clamp(6vh, 8vh, 50px); 
  transition:transform 0.12s; 
}
.play-btn.stop { background:#FF3B30; box-shadow:0 10px 30px #000A, 0 0 40px #FF3B3088; }
.play-btn:active { transform:scale(0.92); }
</style>
</head>
<body>

<div id="app">
  <header>
    <div class="app-title">Roppon Code Editor</div>
    <div class="header-content">
      <div class="setting-group">
        <div class="setting-label">BPM</div>
        <select id="bpm-select" class="global-select"></select>
      </div>
      <div class="setting-group">
        <div class="setting-label">KEY</div>
        <select id="key-select" class="global-select"></select>
      </div>
      <div class="setting-group">
        <div class="setting-label">BEAT</div>
        <select id="beat-select" class="global-select">
          <option value="4">4</option>
          <option value="8" selected>8</option>
          <option value="16">16</option>
        </select>
      </div>
      <div class="setting-group">
        <div class="setting-label">DRUM</div>
        <select id="drum-select" class="global-select">
          <option value="1" selected>METRO</option>
          <option value="2">BASIC</option>
          <option value="3">HOUSE</option>
          <option value="4">ROCK8</option>
          <option value="5">DANCE16</option>
        </select>
      </div>
    </div>
  </header>

  <div class="col-headers">
    <div class="col-h-loop">roop</div>
    <div class="col-h-part">Part</div>
    <div class="col-h-chord">Chords</div>
    <div class="col-h-tmpl">Template</div>
  </div>

  <main id="line-container">
    <!-- Lines injected here -->
  </main>

  <div class="controls-overlay">
    <div class="add-btn" id="add-btn">+</div>
    <div class="page-dots">
      <div class="dot"></div>
      <div class="dot"></div>
      <div class="dot active"></div>
      <div class="dot"></div>
    </div>
    <div class="play-btn play" id="play-btn">PLAY</div>
  </div>
</div>

<script>
// Ver.1.7 - タイトル灰色 + +ボタンPLAYの上配置
const KEYS = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
const PARTS = ["Intro", "A", "B", "Pre-Chorus", "Chorus", "Interlude", "C", "Outro"];
const PARTS_DISPLAY = ["イントロ", "Aメロ", "Bメロ", "プレコーラス", "サビ", "間奏", "Cメロ", "アウトロ"];

const TEMPLATES = [
  { name: "王道進行", deg: ["I", "V", "vi", "IV"], usage: "サビ最頻出" },
  { name: "マイナー王道", deg: ["vi", "IV", "I", "V"], usage: "切な系サビ" },
  { name: "逆王道", deg: ["IV", "V", "iii", "vi"], usage: "A・Bメロ" },
  { name: "小室進行", deg: ["vi", "IV", "V", "I"], usage: "90s疾走" },
  { name: "丸サ進行", deg: ["IV", "V", "iii", "vi"], usage: "歌い出し" },
  { name: "カノン進行", deg: ["I", "V", "vi", "iii", "IV", "I", "IV", "V"], usage: "バラード" },
  { name: "4度進行", deg: ["I", "IV", "V", "I"], usage: "明るい" },
  { name: "泣き進行", deg: ["I", "iii", "vi", "V"], usage: "感動" },
  { name: "青春進行", deg: ["I", "V", "IV", "V"], usage: "爽やか" },
  { name: "Bメロ定番", deg: ["ii", "V", "I"], usage: "解決感" },
  { name: "ロック定番", deg: ["I", "bVII", "IV"], usage: "洋楽風" },
  { name: "エモ進行", deg: ["vi", "I", "V", "IV"], usage: "エモい" }
];

const DEGREE_MAP = {
  "I": 0, "II": 2, "ii": 2, "III": 4, "iii": 4, "IV": 5, "V": 7, "VI": 9, "vi": 9, "VII": 11, "bVII": 10
};

let state = {
  bpm: 120,
  pendingBPM: null,
  keyIndex: 0,
  beat: 8,
  drum: 1,
  isPlaying: false,
  lines: [],
  currentLineIndex: -1,
  nextNoteTime: 0,
  currentBeat: 0
};

let audioCtx;
let keepAliveOsc = null;
let lookahead = 25.0;
let scheduleAheadTime = 0.1;
let timerID;

function getNoteFromKey(degree, keyIndex) {
  let offset = DEGREE_MAP[degree] || 0;
  let noteIndex = (keyIndex + offset) % 12;
  let noteName = KEYS[noteIndex];
  let quality = "";
  if (degree === "ii" || degree === "iii" || degree === "vi") quality = "m";
  if (degree.match(/^[a-z]/) && degree !== "bVII") quality = "m";
  return noteName + quality;
}

function generateChordsFromTemplate(templateIndex, keyIndex) {
  if (templateIndex === "") return "";
  const tmpl = TEMPLATES[templateIndex];
  if (!tmpl) return "";
  return tmpl.deg.map(d => getNoteFromKey(d, keyIndex)).join("-");
}

function transposeChordString(chordStr, semitones) {
  if (!chordStr) return "";
  return chordStr.split("-").map(c => {
    c = c.trim();
    if (!c) return "";
    let match = c.match(/^([A-G])(#|b)?(.*)$/);
    if (!match) return c;
    let root = match[1];
    let acc = match[2] || "";
    let suffix = match[3] || "";
    let note = root + acc;
    if (note === "Db") note = "C#";
    if (note === "Eb") note = "D#";
    if (note === "Gb") note = "F#";
    if (note === "Ab") note = "G#";
    if (note === "Bb") note = "A#";
    if (note === "Cb") note = "B";
    let idx = KEYS.indexOf(note);
    if (idx === -1) return c;
    let newIdx = (idx + semitones + 12) % 12;
    return KEYS[newIdx] + suffix;
  }).join("-");
}

const container = document.getElementById('line-container');
const bpmSelect = document.getElementById('bpm-select');
const keySelect = document.getElementById('key-select');
const beatSelect = document.getElementById('beat-select');
const drumSelect = document.getElementById('drum-select');
const playBtn = document.getElementById('play-btn');

function populateSelects() {
  for (let i = 60; i <= 200; i++) {
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = i;
    bpmSelect.appendChild(opt);
  }
  KEYS.forEach((key, index) => {
    const opt = document.createElement('option');
    opt.value = index;
    opt.textContent = key;
    keySelect.appendChild(opt);
  });
}

function renderLine(line, index) {
  const div = document.createElement('div');
  div.className = 'line-row';
  div.dataset.index = index;

  const loopBtn = document.createElement('div');
  loopBtn.className = `loop-btn ${line.loop ? 'active' : ''}`;
  loopBtn.onclick = () => toggleLoop(index);

  const partWrap = document.createElement('div');
  partWrap.className = 'part-wrapper';
  const partSel = document.createElement('select');
  partSel.innerHTML = PARTS.map((p, i) => `<option value="${p}" ${p===line.part?'selected':''}>${PARTS_DISPLAY[i]}</option>`).join('');
  partSel.onchange = (e) => updateLine(index, 'part', e.target.value);
  partSel.classList.add(`part-${line.part}`);
  partWrap.appendChild(partSel);

  const chordWrap = document.createElement('div');
  chordWrap.className = 'chord-wrapper';
  const chordIn = document.createElement('input');
  chordIn.className = 'chords-input';
  chordIn.value = line.chords;
  chordIn.placeholder = "例: C-G-Am-F";
  chordIn.onchange = (e) => updateLine(index, 'chords', e.target.value);
  chordWrap.appendChild(chordIn);

  const pencil = document.createElement('span');
  pencil.className = 'edit-icon';
  pencil.textContent = '✏️';
  chordWrap.appendChild(pencil);

  const tempWrap = document.createElement('div');
  tempWrap.className = 'template-wrapper';
  const tempSel = document.createElement('select');
  const options = TEMPLATES.map((t, i) => {
    const cEx = t.deg.map(d => getNoteFromKey(d, state.keyIndex)).join("-");
    const label = `${t.name} / ${t.deg.join("-")} / ${cEx} / ${t.usage}`;
    return `<option value="${i}" ${i.toString()===line.template?'selected':''}>${label}</option>`;
  }).join('');
  tempSel.innerHTML = '<option value="">Template</option>' + options;
  tempSel.onchange = (e) => applyTemplate(index, e.target.value);
  tempWrap.appendChild(tempSel);

  div.appendChild(loopBtn);
  div.appendChild(partWrap);
  div.appendChild(chordWrap);
  div.appendChild(tempWrap);

  return div;
}

function refreshUI() {
  const btn = document.getElementById('add-btn');
  while (container.firstChild && container.firstChild !== btn) {
    container.removeChild(container.firstChild);
  }
  state.lines.forEach((line, i) => {
    container.insertBefore(renderLine(line, i), btn);
  });

  bpmSelect.value = state.bpm;
  keySelect.value = state.keyIndex;
  beatSelect.value = state.beat;
  drumSelect.value = state.drum;

  document.querySelectorAll('.line-row').forEach(el => el.classList.remove('playing'));
  if (state.currentLineIndex >= 0) {
    updatePlayingClass(state.currentLineIndex);
  }
}

function updateLine(index, field, value) {
  state.lines[index][field] = value;
  saveData();
  refreshUI();
}

function toggleLoop(index) {
  state.lines[index].loop = !state.lines[index].loop;
  refreshUI();
  saveData();
}

function applyTemplate(index, tempIndex) {
  if (tempIndex === "") return;
  state.lines[index].template = tempIndex;
  const chords = generateChordsFromTemplate(tempIndex, state.keyIndex);
  state.lines[index].chords = chords;
  refreshUI();
  saveData();
}

function addLine() {
  state.lines.push({
    loop: false,
    part: "A",
    chords: "",
    template: ""
  });
  refreshUI();
  container.scrollTop = container.scrollHeight;
  saveData();
}

keySelect.onchange = (e) => {
  const newKeyIndex = parseInt(e.target.value);
  const delta = newKeyIndex - state.keyIndex;
  state.keyIndex = newKeyIndex;
  state.lines.forEach(line => {
    line.chords = transposeChordString(line.chords, delta);
  });
  refreshUI();
  saveData();
};

bpmSelect.onchange = (e) => {
  let val = parseInt(e.target.value);
  if (state.isPlaying) {
    state.pendingBPM = val;
  } else {
    state.bpm = val;
    saveData();
  }
};

beatSelect.onchange = (e) => {
  state.beat = parseInt(e.target.value);
  saveData();
};

drumSelect.onchange = (e) => {
  state.drum = parseInt(e.target.value);
  saveData();
};

// +ボタンイベント - 確実に付与
const addBtn = document.getElementById('add-btn');
addBtn.addEventListener('click', addLine);
addBtn.addEventListener('touchstart', (e) => {
  e.preventDefault();
  addLine();
});

// Storage
function saveData() {
  localStorage.setItem('ropponState', JSON.stringify(state));
}

function loadData() {
  const saved = localStorage.getItem('ropponState');
  if (saved) {
    state = JSON.parse(saved);
  }
  refreshUI();
}

// Audio (METRO仮)
function initAudio() {
  if (!audioCtx) {
    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContextClass({ latencyHint: "interactive" });
  }
}

async function unlockAudio() {
  if (!audioCtx) initAudio();
  if (audioCtx.state !== "running") await audioCtx.resume();
  if (!keepAliveOsc) {
    keepAliveOsc = audioCtx.createOscillator();
    keepAliveOsc.type = 'sine';
    keepAliveOsc.frequency.value = 1;
    const gain = audioCtx.createGain();
    gain.gain.value = 0.0001;
    keepAliveOsc.connect(gain);
    gain.connect(audioCtx.destination);
    keepAliveOsc.start(0);
  }
}

document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible' && audioCtx && audioCtx.state !== 'running') {
    audioCtx.resume();
  }
});

function playTone(freq, time, duration, type = 'triangle') {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start(time);
  gain.gain.setValueAtTime(0.3, time);
  gain.gain.exponentialRampToValueAtTime(0.01, time + duration);
  osc.stop(time + duration);
}

function playDrum(time, type) {
  if (type === 'metro') {
    playTone(880, time, 0.03, 'sine');
  }
}

// Scheduler & Play
function getFirstActiveLineIndex() {
  return state.lines.findIndex(l => l.loop);
}

function getNextActiveLineIndex(current) {
  for (let i = current + 1; i < state.lines.length; i++) if (state.lines[i].loop) return i;
  for (let i = 0; i < state.lines.length; i++) if (state.lines[i].loop) return i;
  return -1;
}

function nextNote() {
  const beatTime = 60 / state.bpm / (state.beat / 4);
  state.nextNoteTime += beatTime;
  state.currentBeat++;

  if (state.currentLineIndex === -1) return;

  const currentLine = state.lines[state.currentLineIndex];
  const chords = currentLine.chords.split("-").filter(c => c.trim());
  if (chords.length === 0) {
    state.currentBeat = 0;
    const nextIndex = getNextActiveLineIndex(state.currentLineIndex);
    if (nextIndex !== -1) {
      updatePlayingClass(nextIndex);
      state.currentLineIndex = nextIndex;
    }
    return;
  }

  const beatsPerChord = state.beat;
  const beatsPerLine = chords.length * beatsPerChord;

  if (state.currentBeat >= beatsPerLine) {
    state.currentBeat = 0;
    const nextIndex = getNextActiveLineIndex(state.currentLineIndex);
    if (nextIndex === -1) {
      playBtn.click();
    } else {
      updatePlayingClass(nextIndex);
      state.currentLineIndex = nextIndex;
    }
  }
}

function updatePlayingClass(newIndex) {
  document.querySelectorAll('.line-row').forEach(el => el.classList.remove('playing'));
  if (newIndex >= 0) {
    const newEl = document.querySelector(`.line-row[data-index="${newIndex}"]`);
    if (newEl) newEl.classList.add('playing');
  }
}

function scheduleNote(beatNumber, time) {
  if (state.currentLineIndex === -1) return;

  const currentLine = state.lines[state.currentLineIndex];
  const chords = currentLine.chords.split("-").filter(c => c.trim());
  if (chords.length === 0) return;

  const beatsPerChord = state.beat;
  const chordIndex = Math.floor(beatNumber / beatsPerChord);
  const beatInChord = beatNumber % beatsPerChord;

  if (beatInChord === 0 && chordIndex < chords.length) {
    const chord = chords[chordIndex].trim();
    if (!chord) return;
    let rootNote = chord.replace(/m$/, '');
    const isMinor = chord.endsWith('m');
    const rootIndex = KEYS.indexOf(rootNote);
    if (rootIndex === -1) return;
    const third = isMinor ? 3 : 4;
    const fifth = 7;
    const notes = [rootIndex, (rootIndex + third) % 12, (rootIndex + fifth) % 12];
    notes.forEach(offset => {
      const midi = 60 + offset;
      const freq = 440 * Math.pow(2, (midi - 69) / 12);
      playTone(freq, time, 0.5, 'triangle');
    });
  }

  if (state.drum === 1 && beatInChord % (state.beat / 4) === 0) {
    playDrum(time, 'metro');
  }
}

function scheduler() {
  while (state.nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
    scheduleNote(state.currentBeat, state.nextNoteTime);
    nextNote();
  }
  timerID = window.setTimeout(scheduler, lookahead);
}

playBtn.onclick = async () => {
  if (!audioCtx) initAudio();
  await audioCtx.resume();

  if (state.isPlaying) {
    state.isPlaying = false;
    window.clearTimeout(timerID);
    playBtn.textContent = "PLAY";
    playBtn.className = "play-btn play";
    document.querySelectorAll('.line-row').forEach(el => el.classList.remove('playing'));
    state.currentBeat = 0;
    state.currentLineIndex = -1;
    if (state.pendingBPM !== null) {
      state.bpm = state.pendingBPM;
      state.pendingBPM = null;
      bpmSelect.value = state.bpm;
      saveData();
    }
  } else {
    if (state.lines.length === 0 || getFirstActiveLineIndex() === -1) return;
    await unlockAudio();
    state.isPlaying = true;
    state.currentBeat = 0;
    state.currentLineIndex = getFirstActiveLineIndex();
    state.nextNoteTime = audioCtx.currentTime + 0.1;
    playBtn.textContent = "STOP";
    playBtn.className = "play-btn stop";
    updatePlayingClass(state.currentLineIndex);
    scheduler();
  }
};

populateSelects();
loadData();

if (state.currentLineIndex >= 0) {
  updatePlayingClass(state.currentLineIndex);
} else {
  document.querySelectorAll('.line-row').forEach(el => el.classList.remove('playing'));
}
</script>
</body>
</html>
