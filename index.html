<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="screen-orientation" content="portrait">
<!--
ゲーム要件:
App Name: Roppon Code Editor
Type: Web Application
Platform: iPhone (Portrait Only)
Orientation: Portrait Fixed
Screen Structure: 1 Screen, No Transition
Layout: Header 10%, List 70%, Bottom Margin 20% (Empty, No UI)
Features:
- BPM: Immediate/Pending update logic
- Key: 0-11 Integer, Transpose immediately, No flats
- Loop: Playlist filter (Top to Bottom, Skip OFF)
- Audio: Drum + Piano, No silent frames
- Storage: LocalStorage Auto Save/Load
-->
<title>Roppon Code Editor</title>
<style>
/* CSS Reset & Basics */
* { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
body { margin: 0; padding: 0; background-color: #000000; color: #ffffff; overflow: hidden; width: 100vw; height: 100vh; touch-action: none; }
input, select, button { outline: none; border: none; background: none; color: inherit; font-family: inherit; }

/* Layout Grid */
#app { display: flex; flex-direction: column; width: 100%; height: 100%; overflow: hidden; }

/* Header (10%) */
header { flex: 0 0 10%; width: 100%; padding-top: env(safe-area-inset-top); background: #000; z-index: 10; display: flex; flex-direction: column; align-items: center; padding-bottom: 1vh; }
.app-title { width: 100%; text-align: center; font-size: 4vw; font-weight: bold; color: #fff; margin-bottom: 1vh; }
.header-content { width: 96%; margin: 0 auto; height: 70%; display: flex; justify-content: space-between; gap: 1vw; }

.setting-group { flex: 1; display: flex; flex-direction: column; justify-content: flex-end; background: #1a1a1a; border-radius: 6px; position: relative; height: 100%; }
.setting-label { position: absolute; top: -2vh; left: 0; width: 100%; text-align: center; font-size: 2.5vw; color: #888; font-weight: bold; }

/* Global Select Styles */
.global-select { width: 100%; height: 100%; text-align: center; font-size: 4.5vw; font-weight: bold; color: #fff; background: transparent; appearance: none; border-radius: 6px; padding: 0; text-align-last: center; }
.global-select:focus { background: #222; }

/* Specific widths if needed, but flex:1 handles it */
#bpm-select { color: #4CCFFF; }
#key-select { color: #FFD60A; }
#beat-select { color: #FF9F0A; }
#hat-select { color: #32D74B; }

/* Main List (70%) */
#list-wrapper { flex: 0 0 70%; display: flex; flex-direction: column; position: relative; overflow: hidden; }

/* Headers for columns */
.col-headers { display: flex; width: 100%; padding: 0 4vw; height: 4vh; align-items: center; color: #666; font-size: 3vw; font-weight: bold; background: #000; flex-shrink: 0; }
.col-h-loop { width: 7%; }
.col-h-part { width: 18%; margin-left: 1%; }
.col-h-chord { width: 40%; margin-left: 2%; }
.col-h-temp { width: 35%; margin-left: 2%; }

main { flex: 1; overflow-y: auto; position: relative; padding: 1vh 3% 18vh 3%; -webkit-overflow-scrolling: touch; width: 100%; }
/* Hide scrollbar */
main::-webkit-scrollbar { display: none; }

.line-row { height: 8vh; display: flex; align-items: center; justify-content: space-between; margin-bottom: 1vh; position: relative; background: #111; border-radius: 8px; padding: 0 1vw; transition: background 0.2s; flex-shrink: 0; }
.line-row.playing { border: 1px solid #4CCFFF; box-shadow: 0 0 10px rgba(76, 207, 255, 0.3); }

/* Loop Btn */
.loop-btn { width: 6vw; height: 6vw; border-radius: 50%; border: 2px solid #444; cursor: pointer; transition: all 0.2s; flex-shrink: 0; margin-left: 0.5vw; }
.loop-btn.active { background-color: #4CCFFF; border-color: #4CCFFF; box-shadow: 0 0 8px #4CCFFF; }

/* Part Select */
.part-wrapper { position: relative; width: 18%; height: 80%; }
.part-wrapper::after { content: '▼'; position: absolute; right: 0.5vw; top: 50%; transform: translateY(-50%); font-size: 1.8vw; color: #4CCFFF; pointer-events: none; }
.part-wrapper select { width: 100%; height: 100%; background: #222; color: #fff; border-radius: 4px; padding: 0 1.5vw 0 0.5vw; font-size: 2.8vw; }

/* Chords Input */
.chords-input { width: 40%; height: 80%; background: #222; border-radius: 4px; font-size: 3.5vw; color: #fff; padding: 0 2vw; border: 1px solid #333; }
.chords-input::placeholder { color: #555; font-size: 2.5vw; }

/* Template Select */
.template-wrapper { position: relative; width: 35%; height: 80%; }
.template-wrapper::after { content: '▼'; position: absolute; right: 0.5vw; top: 50%; transform: translateY(-50%); font-size: 1.8vw; color: #4CCFFF; pointer-events: none; }
.template-wrapper select { width: 100%; height: 100%; background: #222; color: #aaa; border-radius: 4px; padding: 0 1.5vw 0 0.5vw; font-size: 3.5vw; }

/* Add Button */
.add-btn { width: 100%; height: 8vh; background: none; color: #666; font-size: 8vw; display: flex; align-items: center; justify-content: center; cursor: pointer; font-weight: bold; margin-top: 1vh; flex-shrink: 0; }
.add-btn:active { color: #fff; }

/* Controls Overlay */
.controls-overlay { position: absolute; bottom: 0; left: 0; width: 100%; height: 25%; display: flex; flex-direction: column; align-items: center; justify-content: flex-end; pointer-events: none; background: linear-gradient(to top, #000 40%, transparent); z-index: 50; padding-bottom: 2vh; }

.page-dots { display: flex; gap: 1.5vw; margin-bottom: 3vh; }
.dot { width: 1.2vw; height: 1.2vw; border-radius: 50%; background: #333; }
.dot.active { background: #4CCFFF; }

.play-btn { width: 20vw; height: 20vw; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 4vw; font-weight: bold; color: #fff; cursor: pointer; box-shadow: 0 4px 15px rgba(0,0,0,0.5); transition: transform 0.1s; pointer-events: auto; z-index: 51; }
.play-btn.stop { background: #FF3B30; box-shadow: 0 0 20px rgba(255, 59, 48, 0.4); }
.play-btn.play { background: #34C759; box-shadow: 0 0 20px rgba(52, 199, 89, 0.4); }
.play-btn:active { transform: scale(0.95); }

/* Bottom Spacer (20%) - Strictly Empty */
#bottom-spacer { flex: 0 0 20%; width: 100%; background: #000; padding-bottom: env(safe-area-inset-bottom); }

</style>
</head>
<body>

<div id="app">
  <header>
    <div class="app-title">Roppon Code Editor</div>
    <div class="header-content">
      <div class="setting-group">
        <div class="setting-label">BPM</div>
        <select id="bpm-select" class="global-select"></select>
      </div>
      <div class="setting-group">
        <div class="setting-label">KEY</div>
        <select id="key-select" class="global-select"></select>
      </div>
      <div class="setting-group">
        <div class="setting-label">BEAT</div>
        <select id="beat-select" class="global-select">
          <option value="4">4</option>
          <option value="8" selected>8</option>
          <option value="16">16</option>
        </select>
      </div>
      <div class="setting-group">
        <div class="setting-label">HAT</div>
        <select id="hat-select" class="global-select">
          <option value="1" selected>Straight</option>
          <option value="2">Shuffle</option>
          <option value="3">Open</option>
          <option value="4">Trap</option>
        </select>
      </div>
    </div>
  </header>

  <div id="list-wrapper">
    <div class="col-headers">
      <div class="col-h-loop">roop</div>
      <div class="col-h-part">Part</div>
      <div class="col-h-chord">Chords</div>
      <div class="col-h-temp">Template</div>
    </div>
    <main id="line-container">
      <!-- Lines injected here -->
      <div class="add-btn" id="add-btn">+</div>
    </main>
    <div class="controls-overlay">
      <div class="page-dots">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot active"></div>
        <div class="dot"></div>
      </div>
      <div class="play-btn play" id="play-btn">PLAY</div>
    </div>
  </div>

  <div id="bottom-spacer"></div>
</div>

<script>
// --- Constants & Data ---
const KEYS = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
const PARTS = ["Intro", "A", "B", "Pre-Chorus", "Chorus", "Interlude", "C", "Outro"];
const PARTS_DISPLAY = ["イントロ", "Aメロ", "Bメロ", "プレコーラス", "サビ", "間奏", "Cメロ", "アウトロ"];

// Templates with Degrees
const TEMPLATES = [
  { name: "王道進行", deg: ["I", "V", "vi", "IV"], usage: "サビ最頻出" },
  { name: "マイナー王道", deg: ["vi", "IV", "I", "V"], usage: "切な系サビ" },
  { name: "逆王道", deg: ["IV", "V", "iii", "vi"], usage: "A・Bメロ" },
  { name: "小室進行", deg: ["vi", "IV", "V", "I"], usage: "90s疾走" },
  { name: "丸サ進行", deg: ["IV", "V", "iii", "vi"], usage: "歌い出し" },
  { name: "カノン進行", deg: ["I", "V", "vi", "iii", "IV", "I", "IV", "V"], usage: "バラード" },
  { name: "4度進行", deg: ["I", "IV", "V", "I"], usage: "明るい" },
  { name: "泣き進行", deg: ["I", "iii", "vi", "V"], usage: "感動" },
  { name: "青春進行", deg: ["I", "V", "IV", "V"], usage: "爽やか" },
  { name: "Bメロ定番", deg: ["ii", "V", "I"], usage: "解決感" },
  { name: "ロック定番", deg: ["I", "bVII", "IV"], usage: "洋楽風" },
  { name: "エモ進行", deg: ["vi", "I", "V", "IV"], usage: "エモい" }
];

// Degree to Semitone Offset from Root
const DEGREE_MAP = {
  "I": 0, "II": 2, "ii": 2, "III": 4, "iii": 4, "IV": 5, "V": 7, "VI": 9, "vi": 9, "VII": 11, "bVII": 10
};

// --- State ---
let state = {
  bpm: 120,
  pendingBPM: null,
  keyIndex: 0, // Index in KEYS (0 = C)
  beat: 8,
  hat: 1,
  isPlaying: false,
  lines: [], // { loop, part, chords, template }
  currentLineIndex: -1,
  nextNoteTime: 0,
  currentBeat: 0
};

// --- Audio Context ---
let audioCtx;
let keepAliveOsc = null;
let lookahead = 25.0;
let scheduleAheadTime = 0.1;
let timerID;

// --- Logic: Transposition & Chords ---

function getNoteFromKey(degree, keyIndex) {
  let offset = DEGREE_MAP[degree] || 0;
  let noteIndex = (keyIndex + offset) % 12;
  let noteName = KEYS[noteIndex];
  
  let quality = "";
  if (degree === "ii" || degree === "iii" || degree === "vi") quality = "m";
  if (degree.match(/^[a-z]/) && degree !== "bVII") quality = "m";
  
  return noteName + quality;
}

function generateChordsFromTemplate(templateIndex, keyIndex) {
  if (templateIndex === "") return "";
  const tmpl = TEMPLATES[templateIndex];
  if (!tmpl) return "";
  return tmpl.deg.map(d => getNoteFromKey(d, keyIndex)).join("-");
}

function transposeChordString(chordStr, semitones) {
  if (!chordStr) return "";
  return chordStr.split("-").map(c => {
    c = c.trim();
    if (!c) return "";
    let match = c.match(/^([A-G])(#|b)?(.*)$/);
    if (!match) return c;
    let root = match[1];
    let acc = match[2] || "";
    let suffix = match[3] || "";
    
    let note = root + acc;
    if (note === "Db") note = "C#";
    if (note === "Eb") note = "D#";
    if (note === "Gb") note = "F#";
    if (note === "Ab") note = "G#";
    if (note === "Bb") note = "A#";
    if (note === "Cb") note = "B";
    
    let idx = KEYS.indexOf(note);
    if (idx === -1) return c;
    
    let newIdx = (idx + semitones + 12) % 12;
    return KEYS[newIdx] + suffix;
  }).join("-");
}

// --- UI Rendering ---

const container = document.getElementById('line-container');
const bpmSelect = document.getElementById('bpm-select');
const keySelect = document.getElementById('key-select');
const beatSelect = document.getElementById('beat-select');
const hatSelect = document.getElementById('hat-select');
const playBtn = document.getElementById('play-btn');

function populateSelects() {
  // Populate BPM
  for (let i = 60; i <= 200; i++) {
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = i;
    bpmSelect.appendChild(opt);
  }

  // Populate KEY
  KEYS.forEach((key, index) => {
    const opt = document.createElement('option');
    opt.value = index;
    opt.textContent = key;
    keySelect.appendChild(opt);
  });
}

function renderLine(line, index) {
  const div = document.createElement('div');
  div.className = 'line-row';
  div.dataset.index = index;

  // Loop Toggle
  const loopBtn = document.createElement('div');
  loopBtn.className = `loop-btn ${line.loop ? 'active' : ''}`;
  loopBtn.onclick = () => toggleLoop(index);

  // Part Select
  const partWrap = document.createElement('div');
  partWrap.className = 'part-wrapper';
  const partSel = document.createElement('select');
  partSel.innerHTML = PARTS.map((p, i) => `<option value="${p}" ${p===line.part?'selected':''}>${PARTS_DISPLAY[i]}</option>`).join('');
  partSel.onchange = (e) => updateLine(index, 'part', e.target.value);
  partWrap.appendChild(partSel);

  // Chords Input
  const chordIn = document.createElement('input');
  chordIn.className = 'chords-input';
  chordIn.value = line.chords;
  chordIn.placeholder = "例: C-G-Am-F";
  chordIn.onchange = (e) => updateLine(index, 'chords', e.target.value);

  // Template Select
  const tempWrap = document.createElement('div');
  tempWrap.className = 'template-wrapper';
  const tempSel = document.createElement('select');

  const options = TEMPLATES.map((t, i) => {
    const cEx = t.deg.map(d => getNoteFromKey(d, 0)).join("-");
    const label = `${t.name} / ${t.deg.join("-")} / ${cEx} / ${t.usage}`;
    return `<option value="${i}" ${i.toString()===line.template?'selected':''}>${label}</option>`;
  }).join('');
  tempSel.innerHTML = '<option value="">Template</option>' + options;
  tempSel.onchange = (e) => applyTemplate(index, e.target.value);
  tempWrap.appendChild(tempSel);

  div.appendChild(loopBtn);
  div.appendChild(partWrap);
  div.appendChild(chordIn);
  div.appendChild(tempWrap);

  return div;
}

function refreshUI() {
  const btn = document.getElementById('add-btn');
  while (container.firstChild && container.firstChild !== btn) {
    container.removeChild(container.firstChild);
  }
  state.lines.forEach((line, i) => {
    container.insertBefore(renderLine(line, i), btn);
  });

  bpmSelect.value = state.bpm;
  keySelect.value = state.keyIndex;
  beatSelect.value = state.beat;
  hatSelect.value = state.hat;
}

function updateLine(index, field, value) {
  state.lines[index][field] = value;
  saveData();
  refreshUI();
}

function toggleLoop(index) {
  state.lines[index].loop = !state.lines[index].loop;
  refreshUI();
  saveData();
}

function applyTemplate(index, tempIndex) {
  if (tempIndex === "") return;
  state.lines[index].template = tempIndex;
  const chords = generateChordsFromTemplate(tempIndex, state.keyIndex);
  state.lines[index].chords = chords;
  refreshUI();
  saveData();
}

function addLine() {
  state.lines.push({
    loop: false,
    part: "A",
    chords: "",
    template: ""
  });
  refreshUI();
  container.scrollTop = container.scrollHeight;
  saveData();
}

// --- Global Settings Handlers ---
keySelect.onchange = (e) => {
  const newKeyIndex = parseInt(e.target.value);
  const delta = newKeyIndex - state.keyIndex;
  state.keyIndex = newKeyIndex;
  
  state.lines.forEach(line => {
    line.chords = transposeChordString(line.chords, delta);
  });
  refreshUI();
  saveData();
};

bpmSelect.onchange = (e) => {
  let val = parseInt(e.target.value);
  if (state.isPlaying) {
    state.pendingBPM = val;
  } else {
    state.bpm = val;
    saveData();
  }
};

beatSelect.onchange = (e) => {
  state.beat = parseInt(e.target.value);
  saveData();
};

hatSelect.onchange = (e) => {
  state.hat = parseInt(e.target.value);
  saveData();
};

document.getElementById('add-btn').onclick = addLine;

// --- Storage ---
function saveData() {
  localStorage.setItem('ropponState', JSON.stringify(state));
}

function loadData() {
  const saved = localStorage.getItem('ropponState');
  if (saved) {
    state = JSON.parse(saved);
  }
  refreshUI();
}

// --- Audio Engine ---

function initAudio() {
  if (!audioCtx) {
    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContextClass({
      latencyHint: "interactive"
    });
  }
}

async function unlockAudio() {
  if (!audioCtx) initAudio();

  if (audioCtx.state !== "running") {
    await audioCtx.resume();
  }

  // Persistent Keep-Alive Oscillator (iOS/Android Fix)
  if (!keepAliveOsc) {
    keepAliveOsc = audioCtx.createOscillator();
    keepAliveOsc.type = 'sine';
    keepAliveOsc.frequency.value = 1; // 1Hz
    const gain = audioCtx.createGain();
    gain.gain.value = 0.0001; // Inaudible
    keepAliveOsc.connect(gain);
    gain.connect(audioCtx.destination);
    keepAliveOsc.start(0);
  }
}

// Visibility Handler
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible' && audioCtx) {
    if (audioCtx.state !== 'running') {
      audioCtx.resume();
    }
  }
});

function playTone(freq, time, duration, type = 'triangle') {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  osc.connect(gain);
  gain.connect(audioCtx.destination);

  osc.start(time);
  gain.gain.setValueAtTime(0.3, time);
  gain.gain.exponentialRampToValueAtTime(0.01, time + duration);
  osc.stop(time + duration);
}

function playDrum(time, type) {
  const gain = audioCtx.createGain();
  gain.connect(audioCtx.destination);

  if (type === 'kick') {
    const osc = audioCtx.createOscillator();
    osc.frequency.setValueAtTime(150, time);
    osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
    gain.gain.setValueAtTime(0.8, time);
    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
    osc.connect(gain);
    osc.start(time);
    osc.stop(time + 0.5);
  } else if (type.startsWith('hat')) {
    const osc = audioCtx.createOscillator();
    osc.type = 'square';

    let freq = 800;
    let decay = 0.05;
    let hatType = 'hat';
    if (type === 'hat-open') { decay = 0.3; }
    if (type === 'hat-trap') { freq = 1200; decay = 0.03; }
    // For shuffle (hat=2), we assume straight for simplicity, no swing implemented

    const filter = audioCtx.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = 4000;

    gain.gain.setValueAtTime(0.1, time);
    gain.gain.exponentialRampToValueAtTime(0.001, time + decay);

    osc.connect(filter);
    filter.connect(gain);

    osc.start(time);
    osc.stop(time + decay + 0.1);
  } else if (type === 'snare') {
    const bufferSize = audioCtx.sampleRate * 0.1;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      data[i] = Math.random() * 2 - 1;
    }
    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;
    const filter = audioCtx.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = 1000;
    noise.connect(filter);
    filter.connect(gain);

    gain.gain.setValueAtTime(0.5, time);
    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
    noise.start(time);
    noise.stop(time + 0.2);
  }
}

// --- Scheduler & Play Control ---

function getFirstActiveLineIndex() {
  return state.lines.findIndex(l => l.loop);
}

function getNextActiveLineIndex(current) {
  for (let i = current + 1; i < state.lines.length; i++) {
    if (state.lines[i].loop) return i;
  }
  for (let i = 0; i < state.lines.length; i++) {
    if (state.lines[i].loop) return i;
  }
  return -1;
}

function nextNote() {
  const beatTime = 60 / state.bpm / (state.beat / 4); // Division time: for beat=8, 8th note time = (60/bpm)/2
  state.nextNoteTime += beatTime;
  state.currentBeat++;

  if (state.currentLineIndex === -1) return;

  const currentLine = state.lines[state.currentLineIndex];
  const chords = currentLine.chords.split("-").filter(c => c.trim());
  if (chords.length === 0) {
    // Skip empty lines
    state.currentBeat = 0;
    const nextIndex = getNextActiveLineIndex(state.currentLineIndex);
    if (nextIndex !== -1) {
      updatePlayingClass(nextIndex);
      state.currentLineIndex = nextIndex;
    }
    return;
  }

  const beatsPerChord = state.beat;
  const beatsPerLine = chords.length * beatsPerChord;

  if (state.currentBeat >= beatsPerLine) {
    state.currentBeat = 0;
    const nextIndex = getNextActiveLineIndex(state.currentLineIndex);
    if (nextIndex === -1) {
      playBtn.click(); // Stop if no more active lines
    } else {
      updatePlayingClass(nextIndex);
      state.currentLineIndex = nextIndex;
    }
  }
}

function updatePlayingClass(newIndex) {
  document.querySelectorAll('.line-row').forEach(el => el.classList.remove('playing'));
  const newEl = document.querySelector(`.line-row[data-index="${newIndex}"]`);
  if (newEl) newEl.classList.add('playing');
}

function scheduleNote(beatNumber, time) {
  if (state.currentLineIndex === -1) return;

  const currentLine = state.lines[state.currentLineIndex];
  const chords = currentLine.chords.split("-").filter(c => c.trim());
  if (chords.length === 0) return;

  const beatsPerChord = state.beat;
  const chordIndex = Math.floor(beatNumber / beatsPerChord);
  const beatInChord = beatNumber % beatsPerChord;

  // Play piano chord at start of each chord (bar)
  if (beatInChord === 0 && chordIndex < chords.length) {
    const chord = chords[chordIndex].trim();
    if (!chord) return;

    let rootNote = chord.replace(/m$/, '');
    const isMinor = chord.endsWith('m');
    const rootIndex = KEYS.indexOf(rootNote);
    if (rootIndex === -1) return;

    const third = isMinor ? 3 : 4;
    const fifth = 7;
    const notes = [rootIndex, (rootIndex + third) % 12, (rootIndex + fifth) % 12];

    notes.forEach(offset => {
      const midi = 60 + offset; // Middle C range
      const freq = 440 * Math.pow(2, (midi - 69) / 12);
      playTone(freq, time, 0.5, 'triangle');
    });
  }

  // Drum patterns
  const stepsPerQuarter = state.beat / 4;
  const quarterBeat = Math.floor(beatInChord / stepsPerQuarter);

  if (beatInChord % stepsPerQuarter === 0) {
    if (quarterBeat === 0 || quarterBeat === 2) {
      playDrum(time, 'kick');
    }
    if (quarterBeat === 1 || quarterBeat === 3) {
      playDrum(time, 'snare');
    }
  }

  // Hat every division
  let hatType = 'hat';
  if (state.hat === 3) hatType = 'hat-open';
  if (state.hat === 4) hatType = 'hat-trap';
  // Shuffle (2) not fully implemented (no swing timing)
  playDrum(time, hatType);
}

function scheduler() {
  while (state.nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
    scheduleNote(state.currentBeat, state.nextNoteTime);
    nextNote();
  }
  timerID = window.setTimeout(scheduler, lookahead);
}

playBtn.onclick = async () => {
  if (!audioCtx) initAudio();
  await audioCtx.resume();

  if (state.isPlaying) {
    state.isPlaying = false;
    window.clearTimeout(timerID);
    playBtn.textContent = "PLAY";
    playBtn.className = "play-btn play";
    document.querySelectorAll('.line-row').forEach(el => el.classList.remove('playing'));
    state.currentBeat = 0;
    state.currentLineIndex = -1;
    if (state.pendingBPM !== null) {
      state.bpm = state.pendingBPM;
      state.pendingBPM = null;
      bpmSelect.value = state.bpm;
      saveData();
    }
  } else {
    if (state.lines.length === 0 || getFirstActiveLineIndex() === -1) return;

    await unlockAudio();

    state.isPlaying = true;
    state.currentBeat = 0;
    state.currentLineIndex = getFirstActiveLineIndex();
    state.nextNoteTime = audioCtx.currentTime + 0.1;
    playBtn.textContent = "STOP";
    playBtn.className = "play-btn stop";
    updatePlayingClass(state.currentLineIndex);
    scheduler();
  }
};

// --- Initialize ---
populateSelects();
loadData();
</script>
</body>
</html>
